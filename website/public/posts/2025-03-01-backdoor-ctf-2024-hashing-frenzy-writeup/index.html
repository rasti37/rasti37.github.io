<!DOCTYPE html>
<html lang='en-us'>
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta property="og:title" content="(Crypto) Backdoor CTF 2024 - Hashing Frenzy">
	<meta name="twitter:title" content="(Crypto) Backdoor CTF 2024 - Hashing Frenzy">
	<meta name="description" content="">
	<meta property="og:description" content="">
	<meta name="twitter:description" content="">
	<meta property="og:type" content="article">
	<meta property="og:url" content="http://localhost:1313/posts/2025-03-01-backdoor-ctf-2024-hashing-frenzy-writeup/">
	<meta property="og:site_name" content="rasti&#39;s knowledge cave">
	<meta name="twitter:card" content="summary_large_image">
	<link rel="icon" type="image/x-icon" href="/thumb.png">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>(Crypto) Backdoor CTF 2024 - Hashing Frenzy</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	############################<br>
	## <a href="http://localhost:1313/" class='header-footer-anchor'>rasti&#39;s knowledge cave</a> ##<br>
	############################
	<div style="float: right;">gatekeeping is for the weak</div><br>
	<nav>
		<a href="/" class='header-footer-anchor'><b>Start</b></a> Â·
		
		
		
		<a href="/posts/" class='header-footer-anchor'><b>Posts</b></a> Â· 
		
		<a href="/categories/" class='header-footer-anchor'><b>Categories</b></a> Â· 
		
		<a href="/tags/" class='header-footer-anchor'><b>Tags</b></a>
		
	</nav>
	
	
</header>
	
<main>
	<article>
		<h1>(Crypto) Backdoor CTF 2024 - Hashing Frenzy</h1>
		<small>Created at: 01/03/2025, 04:16:04</small><br>
		
		
		<br>.:
		
		
		<a href="/tags/ctf-writeups" class='header-footer-anchor'>#ctf-writeups</a>, 
		
		<a href="/tags/crypto" class='header-footer-anchor'>#crypto</a>, 
		
		<a href="/tags/lll" class='header-footer-anchor'>#LLL</a>
		:.
		<div>
			<div style='cursor: pointer; border-radius: 3px; border:1px solid #888; padding: 7px; margin: 1.3em 0 1.3em 0;'>
    <details>
        <summary>Table of Contents</summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#description">Description</a></li>
    <li><a href="#synopsis">Synopsis</a></li>
    <li><a href="#analyzing-the-source-code">Analyzing the source code</a>
      <ul>
        <li><a href="#how-the-signatures-are-generated">How the signatures are generated</a></li>
      </ul>
    </li>
    <li><a href="#solution">Solution</a>
      <ul>
        <li><a href="#recovering-the-prime-modulus">Recovering the prime modulus</a></li>
        <li><a href="#obtaining-the-flag-lattice-reduction-time--best-time">Obtaining the flag (Lattice Reduction time = Best time)</a>
          <ul>
            <li><a href="#setting-up-the-lattice-svp-approach">Setting up the lattice (SVP Approach)</a></li>
            <li><a href="#weighting-the-lattice">Weighting the lattice</a></li>
            <li><a href="#alternative-lattice-setup-cvp-approach">Alternative lattice setup (CVP Approach)</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </details>
</div>
<html>
<style>
    table, td, th {  
        border: 1px solid #ddd;
        text-align: center;
    }
    table {
        border-collapse: collapse;
        margin: 0 auto;
    }
    th, td {
        padding: 7px;
    }
</style>
    <table>
      <tbody>
        <tr>
          <td><b>Category</b></td>
          <td>Crypto</td>
        </tr>
        <tr>
          <td><b>CTF</b></td>
          <td><a href="https://ctftime.org/event/2540/" target="_blank" class='header-footer-anchor'>BackdoorCTF</a></td>
        </tr>
        <tr>
          <td><b>Year</b></td>
          <td>2024</td>
        </tr>
        <tr>
          <td><b>Solves</b></td>
          <td>24</td>
        </tr>
        <tr>
          <td><b>Challenge Author</b></td>
          <td><code>kh4rg0sh</code></td>
        </tr>
      </tbody>
    </table>
</html>
<h1 id="description">Description</h1>
<p>I like the idea of trapdoor functions, so I decided to take the practice of hashing for security to the extreme.</p>
<h1 id="synopsis">Synopsis</h1>
<p>For the passers-by, there were two significant steps for solving this challenge.</p>
<ul>
<li>Recover the prime $p$ by signing two messages and then computing the $\text{GCD}$ of the differences of the reduced and unreduced accumulate values. Sometimes, the primality testing returned false so it was needed to eliminate some small factors too.</li>
<li>Build a lattice using the $6$ flag signatures, the accumulate value and the prime $p$ to solve for the unknowns. One of these unknowns was the flag in plaintext and the rest were just hash digests of the flag from various hash functions.</li>
</ul>
<h1 id="analyzing-the-source-code">Analyzing the source code</h1>
<p>Let&rsquo;s analyze the source <a href="https://github.com/rasti37/CTF-Writeups-and-Notes/blob/main/crypto/BackdoorCTF%202024/Hashing%20Frenzy/src/main.py" target="_blank" rel="noopener">code</a> to figure out how we can obtain the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> flag <span style="color:#f92672">import</span> flag
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">menu</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;1. Sign a message&#34;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;2. Verify a Signature for a message&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>welcome_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;Welcome to My Extra Hashes Extra Secure Edition of my very own Message Signature and Verification Scheme. Since it&#39;s a good practice to use secure hashes, I&#39;ve combined multiple hashes in this scheme.&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>print(welcome_message)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>testing_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;To prove that the scheme works, i&#39;ll test it with a sample message.&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>print(testing_message)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>signatures <span style="color:#f92672">=</span> generate_signatures(flag)
</span></span><span style="display:flex;"><span>print(signatures)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> verify_signature(flag, signatures):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Signature Verified! Your turn. The functions that are allowed are: &#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Signature Verification Failed!&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>menu()
</span></span></code></pre></div><p>The flag is used to generate some signatures and then these signatures are verified along with the flag. This works as a proof of correctness and will always return true. After that, we are asked to either sign our own message or verify our signatures for a given message.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;_&#39;</span>, <span style="color:#e6db74">&#39;__&#39;</span>]:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> _ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;_&#39;</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Let&#39;s sign a message!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Now let&#39;s verify the signature!&#34;</span>)
</span></span><span style="display:flex;"><span>    response <span style="color:#f92672">=</span> ask() 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> response <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        message <span style="color:#f92672">=</span> str(input(<span style="color:#e6db74">&#34;Please enter the message to be signed: &#34;</span>))<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        signatures <span style="color:#f92672">=</span> generate_signatures(message)
</span></span><span style="display:flex;"><span>        print(signatures)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: 
</span></span><span style="display:flex;"><span>        message <span style="color:#f92672">=</span> str(input(<span style="color:#e6db74">&#34;Please enter the message to be verified: &#34;</span>))<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>        signatures <span style="color:#f92672">=</span> list(map(int, input(<span style="color:#e6db74">&#34;Please enter the signature to be verified: &#34;</span>)<span style="color:#f92672">.</span>split()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(signatures) <span style="color:#f92672">==</span> len(hashes) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> verify_signature(message, signatures):
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">&#34;Signature Verified!&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">&#34;Signature Verification Failed!&#34;</span>)
</span></span><span style="display:flex;"><span>                    exit(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>:
</span></span><span style="display:flex;"><span>            exit(<span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>This loop runs two times and is intended to work in a specific manner; the first time, we sign a message and get the corresponding signatures and the second time we verify these signatures along with the message.</p>
<p>But, who said we must follow the intended way? Our response is not restricted so we can use it to sign messages two times or verify signatures two times. More to that, later on ðŸ˜Ž.</p>
<h2 id="how-the-signatures-are-generated">How the signatures are generated</h2>
<p>The function that generates the signatures is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_signatures</span>(message):
</span></span><span style="display:flex;"><span>    signatures <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    accumulate <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> hash_object <span style="color:#f92672">in</span> hashes:
</span></span><span style="display:flex;"><span>        signatures<span style="color:#f92672">.</span>append(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">2</span>, p <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        accumulate <span style="color:#f92672">+=</span> bytes_to_long(hash_object(message)<span style="color:#f92672">.</span>digest()) <span style="color:#f92672">*</span> signatures[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">%</span> p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    signatures<span style="color:#f92672">.</span>append(accumulate)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> signatures
</span></span></code></pre></div><p>There is a loop that iterates over a <code>hashes</code> object. This object is initialized in the beginning of the script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> hashlib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">testhash</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">digest</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>data 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## more hashes, more security</span>
</span></span><span style="display:flex;"><span>hashes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>hashes<span style="color:#f92672">.</span>append(testhash)
</span></span><span style="display:flex;"><span>hashes<span style="color:#f92672">.</span>append(hashlib<span style="color:#f92672">.</span>md5)
</span></span><span style="display:flex;"><span>hashes<span style="color:#f92672">.</span>append(hashlib<span style="color:#f92672">.</span>sha224)
</span></span><span style="display:flex;"><span>hashes<span style="color:#f92672">.</span>append(hashlib<span style="color:#f92672">.</span>sha256)
</span></span><span style="display:flex;"><span>hashes<span style="color:#f92672">.</span>append(hashlib<span style="color:#f92672">.</span>sha3_224)
</span></span><span style="display:flex;"><span>hashes<span style="color:#f92672">.</span>append(hashlib<span style="color:#f92672">.</span>sha3_256)
</span></span></code></pre></div><p>This is basically a list of 6 elements where each element is a different hash function. The first one being a custom one where the digest $H(m)$ is just $M$. The rest functions are <code>MD5</code>, <code>SHA224</code>, <code>SHA256</code>, <code>SHA3-224</code> and <code>SHA3-256</code> with corresponding digest bit lengths: $128, 224, 256, 224, 256$.
For brevity, we will denote the <code>hashes</code> list as $h$. Note that the bit length of $h_0(\text{flag})$ as well as $h_i(\text{flag})$ are unknown since we don&rsquo;t have any information about the flag.</p>
<p>Back to the signature generation function, at iteration $i$, a random number $s_i$ is generated in $[2,\ p-1]$ and used to compute an accumulate value ($\text{A}$) $\in \mathbb{F}_p$ along with $h_i$. The signature generation process for a message $m$ can be described algebraically as:</p>
<p>$$A = s_6 = s_0h_0(m) + s_1h_1(m) + s_2h_2(m) + s_3h_3(m) + s_4h_4(m) + s_5h_5(m) \pmod p$$</p>
<p>or</p>
<p>$$
A = s_6 = \sum_{i = 0}^5{s_ih_i(m)} \pmod p
$$</p>
<p>for short.</p>
<p>where $s_i$ are always known and $h_i(m)$ are known only when we sign our own message. From now on, we omit $(m)$ and we write only $h_i$.</p>
<p>At this point, it&rsquo;s important to note that $p$ is a random $2048$-bit prime which is changed per connection and <em>is unknown</em>.</p>
<p>$p$ is essential as it is required to define $\mathbb{F}_p$ so it would be a good idea to recover it before moving on getting the flag.</p>
<h1 id="solution">Solution</h1>
<p>The rest of the writeup contains the solution of the challenge.</p>
<h2 id="recovering-the-prime-modulus">Recovering the prime modulus</h2>
<p>We mentioned earlier that we do not have to use the protocol as intended. We only have two options and instead of being obedient and sending $(1)$ and then $(2)$, we could send $(1)$ and $(1)$ or $(2)$ and $(2)$.</p>
<p>However, we don&rsquo;t get much information about $p$ if we send $(2)$ two times, only whether the signature is verified or not. Let&rsquo;s focus on the first plan.</p>
<p>Let&rsquo;s look at the signature formula for two messages $m_1, m_2$:</p>
<p>$$
\begin{aligned}
A_1 = \sum_{i = 0}^5 {s_ih_i} \pmod p \\
A_2 = \sum_{i = 0}^5 {s&rsquo;_ih&rsquo;_i} \pmod p
\end{aligned}
$$</p>
<p>where $h_i, h&rsquo;_i, s_i, s&rsquo;_i, A_1, A_2$ are known.</p>
<p>Moving the right hand side in the left hand side, we get&hellip;</p>
<p>$$
\begin{aligned}
A_1 - \sum_{i = 0}^5 {s_ih_i} = 0 \pmod p =  k_1p \\
A_2 - \sum_{i = 0}^5 {s&rsquo;_ih&rsquo;_i} = 0 \pmod p = k_2p
\end{aligned}
$$</p>
<p>&hellip; in other words, two multiples of the prime $p$. Does this ring a bell? Thanks to the one and only Euclid, we can use the GCD to recover the prime $p$ as:</p>
<p>$$
p = \text{GCD}(A_1 - \sum_{i = 0}^5 {s_ih_i},\ A_2 - \sum_{i = 0}^5 {s&rsquo;_ih&rsquo;_i})
$$</p>
<p>The sums are computed without reduction $\pmod p$ and $A_1, A_2$ are the corresponding reduced values $\pmod p$.</p>
<p>However, note the $k_1, k_2$. Sometimes the obtained $p$ will not be prime, this is due to the GCD returning $p$ multiplied with some small constant. We can simply iterate over the first $10^6$ integers ($10^4$ or $10^5$ could work too), check if they are divisible by $p$, and eliminate them by division. Let&rsquo;s write some code for this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_nonreduced_accumulate</span>(message, sigs):
</span></span><span style="display:flex;"><span>    accumulate <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, hash_object <span style="color:#f92672">in</span> enumerate(hashes):
</span></span><span style="display:flex;"><span>        sig <span style="color:#f92672">=</span> sigs[i]
</span></span><span style="display:flex;"><span>        accumulate <span style="color:#f92672">+=</span> bytes_to_long(hash_object(message)<span style="color:#f92672">.</span>digest()) <span style="color:#f92672">*</span> sig
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> accumulate
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_data</span>():
</span></span><span style="display:flex;"><span>    io<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;with a sample message.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    flag_sigs <span style="color:#f92672">=</span> eval(io<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode())
</span></span><span style="display:flex;"><span>    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;choice: &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;signed: &#34;</span>, msg)
</span></span><span style="display:flex;"><span>    m1_sigs <span style="color:#f92672">=</span> eval(io<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode())
</span></span><span style="display:flex;"><span>    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;choice: &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;signed: &#34;</span>, msg)
</span></span><span style="display:flex;"><span>    m2_sigs <span style="color:#f92672">=</span> eval(io<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>decode())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag_sigs, m1_sigs, m2_sigs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recover_p</span>(accumulate1, accumulate2, m1_sigs, m2_sigs):
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> GCD(accumulate1 <span style="color:#f92672">-</span> m1_sigs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], accumulate2 <span style="color:#f92672">-</span> m2_sigs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># eliminate small factors</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">6</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> p <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">//=</span> i
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> isPrime(p) <span style="color:#f92672">and</span> <span style="color:#ae81ff">2047</span> <span style="color:#f92672">&lt;=</span> p<span style="color:#f92672">.</span>bit_length() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2048</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;[-] fail&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>msg <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;r4sti&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>io <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;34.42.147.172&#39;</span>, <span style="color:#ae81ff">8007</span>, level<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;error&#39;</span>)
</span></span><span style="display:flex;"><span>flag_sigs, m1_sigs, m2_sigs <span style="color:#f92672">=</span> get_data()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>accumulate1 <span style="color:#f92672">=</span> generate_nonreduced_accumulate(msg, m1_sigs)
</span></span><span style="display:flex;"><span>accumulate2 <span style="color:#f92672">=</span> generate_nonreduced_accumulate(msg, m2_sigs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> recover_p(accumulate1, accumulate2, m1_sigs, m2_sigs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>p <span style="color:#e6db74">= }</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><h2 id="obtaining-the-flag-lattice-reduction-time--best-time">Obtaining the flag (Lattice Reduction time = Best time)</h2>
<p>The heading should already give you a first idea of the approach to obtain the flag. This section will try to build some intuition on problems that can be solved via lattice reduction techniques and how to approach such problems. We will know focus only on the signatures generated by $\text{M = flag}$.</p>
<p>First things first, let&rsquo;s rewrite the signature generation formula for reference, as well as what we know about each signature-related component:</p>
<p>$$
A = s_6 = \sum_{i = 0}^5{s_ih_i} \pmod p \quad \quad (1)
$$</p>
<p>where,</p>
<ul>
<li>$A,\ s_i,\ p$ are $2048$ bits ($&lt; 2^{2048}$)</li>
<li>$h_0$ has unknown size. We set a hypothetical upper bound of $2^{256}$ which corresponds to a $32$-byte flag.</li>
<li>$h_1$ is $128$ bits ($&lt; 2^{128}$)</li>
<li>$h_2$ is $224$ bits ($&lt; 2^{224}$)</li>
<li>$h_3$ is $256$ bits ($&lt; 2^{256}$)</li>
<li>$h_4$ is $224$ bits ($&lt; 2^{224}$)</li>
<li>$h_5$ is $256$ bits ($&lt; 2^{256}$)</li>
</ul>
<p>This is usually the setup of a problem that requires lattice reduction to be solved; <em>the unknowns $h_i$ are small compared to the modulus and the rest components of the equation</em>. In fact, being $256$ bits while the modulus is $2048$ bits means that the top $2048-256=1792$ bits are just $0$. This is a large portion of the secret information that is leaked and is more than enough to recover the unknowns using LLL.</p>
<p>Let the following lattice spanned by-</p>
<p>No, I am joking. I will get into much detail, hoping that my thought process will be fully understood.</p>
<p>Lattices involve matrices and vectors so let&rsquo;s rewrite $(1)$ as the dot product of two vectors:</p>
<p>$$
A =
\begin{pmatrix}
s_0 &amp; s_1 &amp; s_2 &amp; s_3 &amp; s_4 &amp; s_5
\end{pmatrix}
\cdot
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5
\end{pmatrix}
\pmod p
$$</p>
<p>We will substitute $\pmod p$ with $kp$ where $k$ some integer. Then,</p>
<p>$$
A =
\begin{pmatrix}
s_0 &amp; s_1 &amp; s_2 &amp; s_3 &amp; s_4 &amp; s_5 &amp; p
\end{pmatrix}
\cdot
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; k
\end{pmatrix}
$$</p>
<p>Moreover, let&rsquo;s move everything to the LHS and set the RHS to $0$. We will see later why we want this. Finally:</p>
<p>$$
\begin{pmatrix}
s_0 &amp; s_1 &amp; s_2 &amp; s_3 &amp; s_4 &amp; s_5 &amp; p &amp; -A
\end{pmatrix}
\cdot
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; k &amp; 1
\end{pmatrix}
= 0
$$</p>
<p>The second vector contains all the unknowns while the first is known. We have 6 unknown $h_i$ but only one linear relation which is not enough to use Gaussian elimination.</p>
<h3 id="setting-up-the-lattice-svp-approach">Setting up the lattice (SVP Approach)</h3>
<p>The difficulty in lattice challenges is to figure out how to construct the lattice so that when reduced by LLL, we end up with our target vector. To construct a lattice, we need multiple vectors (i.e. a matrix) and not just a single vector. The question to ask yourself for finding the right lattice is:</p>
<p><em>What matrix should be multiplied with the vector of the unknowns to end up with a target vector that includes some or all of the unknowns?</em></p>
<p>Our unknown vector now is $\begin{pmatrix}h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; k &amp; 1\end{pmatrix}$ and our target vector should contain at least $h_i$. This is where the identity matrix comes in. Think of the following example with fewer unknowns:</p>
<p>$$
h_0
\cdot
\begin{pmatrix}
1\\
0\\
0
\end{pmatrix}
+
h_1
\cdot
\begin{pmatrix}
0\\
1\\
0
\end{pmatrix}
+
h_2
\cdot
\begin{pmatrix}
0\\
0\\
1
\end{pmatrix}
=\
\begin{pmatrix}
h_0\cdot 1 + h_1 \cdot 0 + h_2 \cdot 0\\
h_0\cdot 0 + h_1 \cdot 1 + h_2 \cdot 0\\
h_0\cdot 0 + h_1 \cdot 0 + h_2 \cdot 1\\
\end{pmatrix}
=\
\begin{pmatrix}
h_0\\
h_1\\
h_2\\
\end{pmatrix}
$$</p>
<p>In other words, this is equivalent to the following vector-matrix multiplication:</p>
<p>$$
\begin{pmatrix}
h_0 &amp;
h_1 &amp;
h_2
\end{pmatrix}
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
=\
\begin{pmatrix}
h_0\\
h_1\\
h_2
\end{pmatrix}
$$</p>
<p>It should be clear that using the identity matrix, results in the unknowns being part of the target vector.</p>
<p>In our case, the unknowns are $6$ so consider the following:</p>
<p>$$
h_0
\begin{pmatrix}
1\\
0\\
0\\
0\\
0\\
0\\
s_0\\
\end{pmatrix}
+
h_1
\begin{pmatrix}
0\\
1\\
0\\
0\\
0\\
0\\
s_1\\
\end{pmatrix}
+
h_2
\begin{pmatrix}
0\\
0\\
1\\
0\\
0\\
0\\
s_2\\
\end{pmatrix}
+
h_3
\begin{pmatrix}
0\\
0\\
0\\
1\\
0\\
0\\
s_3\\
\end{pmatrix}
+
h_4
\begin{pmatrix}
0\\
0\\
0\\
0\\
1\\
0\\
s_4\\
\end{pmatrix}
+
h_5
\begin{pmatrix}
0\\
0\\
0\\
0\\
0\\
1\\
s_5\\
\end{pmatrix}
+
k
\begin{pmatrix}
0\\
0\\
0\\
0\\
0\\
0\\
p\\
\end{pmatrix}
+
1
\begin{pmatrix}
0\\
0\\
0\\
0\\
0\\
0\\
-A\\
\end{pmatrix}
=\
\begin{pmatrix}
h_0\\
h_1\\
h_2\\
h_3\\
h_4\\
h_5\\
0\\
\end{pmatrix}
$$</p>
<p>We transposed the matrix because in SageMath, <a href="https://doc.sagemath.org/html/en/reference/matrices/sage/matrix/matrix_integer_dense.html#sage.matrix.matrix_integer_dense.Matrix_integer_dense.LLL" target="_blank" rel="noopener">the lattice is spanned by each row</a>:</p>
<blockquote>
<p>Return LLL-reduced or approximated LLL reduced matrix of the lattice generated by the rows of self.</p></blockquote>
<p>Therefore, our vectors should be the rows of the matrix:</p>
<p>$$
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; k &amp; 1
\end{pmatrix}
\cdot
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_0\\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_1\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; s_2\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; s_3\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; s_4\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; s_5\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; p\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -A\\
\end{bmatrix}
=\
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; 0
\end{pmatrix}
$$</p>
<p>A lattice is just a set that includes all the linear combinations of its bases vectors. Constructing the matrix above, we see that the target vector is part of this set, for <em>some</em> linear combination coefficients. LLL can find this target vector, if the matrix is good enough&hellip; whatever <em>good</em> means.
Let&rsquo;s construct this matrix and reduce it with LLL. Hopefully, the first row of the reduced matrix is our solution vector.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>M <span style="color:#f92672">=</span> block_matrix([
</span></span><span style="display:flex;"><span>        [identity_matrix(<span style="color:#ae81ff">6</span>), matrix(H)<span style="color:#f92672">.</span>T],
</span></span><span style="display:flex;"><span>        [zero_matrix(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>) , matrix([p, <span style="color:#f92672">-</span>A])<span style="color:#f92672">.</span>T]
</span></span><span style="display:flex;"><span>    ], subdivide<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span></code></pre></div><p>(Kudos to <code>Blupper</code> ðŸ”¥ for showing me the <code>block_matrix</code> function ðŸ’¯)</p>
<p>Let&rsquo;s reduce it with LLL:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sage: L <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>LLL()
</span></span><span style="display:flex;"><span>sage: <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> L:
</span></span><span style="display:flex;"><span><span style="color:#f92672">....</span>:     print(i)
</span></span><span style="display:flex;"><span><span style="color:#f92672">....</span>:
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>&hellip; ðŸ¤”. This definitely does not look like the flag, or anything close to it, at all.</p>
<p>What happened here?</p>
<h3 id="weighting-the-lattice">Weighting the lattice</h3>
<p>The problem is here:</p>
<p>$$
1
\begin{pmatrix}
0\\
0\\
0\\
0\\
0\\
0\\
-A\\
\end{pmatrix}
$$</p>
<p>The coefficients of all the other vectors are big ($\simeq 2^{256}$) but the coefficient of the vector above is just $1$. At the same time $-A$ is the only non-zero element of the vector which, it turns out that, results in LLL somehow low-prioritizing this vector. We need to make it as big as the other vectors. This can be achieved by adding an extra element in the vector which is known as a <strong>scaling factor</strong>. Let $B = 2^{256}$ be the scaling factor. Then:</p>
<p>\[
1
\begin{pmatrix}
0\\
0\\
0\\
0\\
0\\
0\\
B\\
-A\\
\end{pmatrix}
\]</p>
<p>Now, the target vector is derived as:</p>
<p>$$
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; k &amp; 1
\end{pmatrix}
\cdot
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_0\\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_1\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_2\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; s_3\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; s_4\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; s_5\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; B &amp; -A\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; p\\
\end{bmatrix}
=\
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; B &amp; 0
\end{pmatrix}
$$</p>
<p>We chose $B = 2^{256}$ because this is the upper bound of $h_i$.</p>
<p>Let&rsquo;s try again with the new matrix:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>B <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>M <span style="color:#f92672">=</span> block_matrix([
</span></span><span style="display:flex;"><span>        [identity_matrix(<span style="color:#ae81ff">7</span>), matrix(H <span style="color:#f92672">+</span> [<span style="color:#f92672">-</span>A])<span style="color:#f92672">.</span>T],
</span></span><span style="display:flex;"><span>        [zero_matrix(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>) , matrix([p])]
</span></span><span style="display:flex;"><span>    ], subdivide<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>M[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> B    <span style="color:#75715e"># set scaling factor</span>
</span></span><span style="display:flex;"><span>L <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>LLL()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> L:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># the solution vector should end with (..., B, 0)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> row[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:] <span style="color:#f92672">==</span> vector([B, <span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>        print(row)
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(<span style="color:#ae81ff">706900059475064292686386702602426630444324681379114804503951298062869885</span>, <span style="color:#ae81ff">10308638735736053502715051302631358691</span>, <span style="color:#ae81ff">4752919295672183050936727141176117974827669306505970380425030364810</span>, <span style="color:#ae81ff">14487800823220630104530546639228420223998682568934955015092250740112699729525</span>, <span style="color:#ae81ff">8295957536049799636308491371051629069883338278363081922835789737524</span>, <span style="color:#ae81ff">92731167790612205135291774049473551292159822402063205170980856740372630056525</span>, <span style="color:#ae81ff">115792089237316195423570985008687907853269984665640564039457584007913129639936</span>, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p><em>Surprisingly, while writing this writeup, I noticed that even if I omit <code>M[-2, -2] = B</code>, LLL still returns the solution vector. The only crucial change was adding an additional column in the matrix; that is the second from last column</em>.</p>
<p>Recall that $h_0$ should be the flag in plaintext. Indeed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> Crypto<span style="color:#f92672">.</span>Util<span style="color:#f92672">.</span>number <span style="color:#f92672">import</span> long_to_bytes
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> long_to_bytes(<span style="color:#ae81ff">706900059475064292686386702602426630444324681379114804503951298062869885</span>)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;flag{more_hashes!=more_secure}&#39;</span>
</span></span></code></pre></div><p>That&rsquo;s it! ðŸ˜Š</p>
<p>Here is a function that does everything we said above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">svp_approach</span>(H, A, p):
</span></span><span style="display:flex;"><span>    B <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>    M <span style="color:#f92672">=</span> block_matrix([
</span></span><span style="display:flex;"><span>            [identity_matrix(<span style="color:#ae81ff">7</span>), matrix(H <span style="color:#f92672">+</span> [<span style="color:#f92672">-</span>A])<span style="color:#f92672">.</span>T],
</span></span><span style="display:flex;"><span>            [zero_matrix(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>) , matrix([p])]
</span></span><span style="display:flex;"><span>        ], subdivide<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>    M[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> B    <span style="color:#75715e"># set scaling factor (turns out this is optional)</span>
</span></span><span style="display:flex;"><span>    L <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>LLL()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> L[<span style="color:#ae81ff">0</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:] <span style="color:#f92672">==</span> vector([B, <span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    flag <span style="color:#f92672">=</span> abs(int(L[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> long_to_bytes(flag)
</span></span></code></pre></div><h3 id="alternative-lattice-setup-cvp-approach">Alternative lattice setup (CVP Approach)</h3>
<p>We are not done yet. During the contest, I was not able to solve it with the SVP approach described in the previous section. In fact, I managed to solve it with the CVP approach which I will describe quite briefly below.</p>
<p>CVP stands for <code>Closest Vector Problem</code> while <code>SVP</code> for <code>Shortest Vector Problem</code>. Informally, and hopefully without making any mistakes, we can say that the SVP is more strict than CVP as it looks for the <em>shortest</em> vector while CVP looks for the <em>closest</em> one. Naturally, we understand that SVP must be more precise, while CVP is more loose.</p>
<p>In a nutshell, the CVP receives a lattice basis B and a target vector $t$ and returns the closest lattice vector to $t$.</p>
<p>For the CVP approach we use a similar lattice as before but now, we will not bother with the scaling factor at all, we will just remove the vector with $-A$ and add $A$ to the target vector. Consider the following:</p>
<p>$$
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; k
\end{pmatrix}
\cdot
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_0\\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; s_1\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; s_2\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; s_3\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; s_4\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; s_5\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; p\\
\end{bmatrix}
$$</p>
<p>We know this multiplication results in the vector:</p>
<p>$$
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; A
\end{pmatrix}
$$</p>
<p>The good thing with CVP is that our target vector can be just the bounds of each of $h_i$. Since $h_i$ are close to $2^{256},\ 2^{128},\ 2^{224},\ 2^{256},\ 2^{224}$ and $2^{256}$ respectively, then the following two vectors should be <em>close enough</em>.</p>
<p>$$
\begin{pmatrix}
2^{256} &amp; 2^{128} &amp; 2^{224} &amp; 2^{256} &amp; 2^{224} &amp; 2^{256} &amp; A
\end{pmatrix}
\simeq
\begin{pmatrix}
h_0 &amp; h_1 &amp; h_2 &amp; h_3 &amp; h_4 &amp; h_5 &amp; A
\end{pmatrix}
$$</p>
<p>This enables CVP to find the second one which is our solution vector.</p>
<p>For solving the CVP, we will use a popular algorithm called <code>Babai's Nearest Plane algorithm</code> and for the time being, we treat it as black-box.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">Babai_CVP</span>(B, target):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> B<span style="color:#f92672">.</span>ncols() <span style="color:#f92672">==</span> len(target)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> sage.modules.free_module_integer <span style="color:#f92672">import</span> IntegerLattice
</span></span><span style="display:flex;"><span>    M <span style="color:#f92672">=</span> IntegerLattice(B, lll_reduce<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>reduced_basis
</span></span><span style="display:flex;"><span>    G <span style="color:#f92672">=</span> M<span style="color:#f92672">.</span>gram_schmidt()[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    small <span style="color:#f92672">=</span> target
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(G<span style="color:#f92672">.</span>nrows())):
</span></span><span style="display:flex;"><span>        small <span style="color:#f92672">-=</span> M[i] <span style="color:#f92672">*</span> ((small <span style="color:#f92672">*</span> G[i]) <span style="color:#f92672">/</span> (G[i] <span style="color:#f92672">*</span> G[i]))<span style="color:#f92672">.</span>round()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> target <span style="color:#f92672">-</span> small
</span></span></code></pre></div><p>Let&rsquo;s construct the matrix in SageMath and run Babai&rsquo;s algorithm.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>M <span style="color:#f92672">=</span> block_matrix([
</span></span><span style="display:flex;"><span>        [identity_matrix(<span style="color:#ae81ff">6</span>), matrix(H)<span style="color:#f92672">.</span>T],
</span></span><span style="display:flex;"><span>        [zero_matrix(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>) , matrix([p])]
</span></span><span style="display:flex;"><span>    ], subdivide<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>target <span style="color:#f92672">=</span> vector(ZZ, [<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">224</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">224</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>, A])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(Babai_CVP(M, target))
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(<span style="color:#ae81ff">706900059475064292686386702602426630444324681379114804503951298062869885</span>, <span style="color:#ae81ff">10308638735736053502715051302631358691</span>, <span style="color:#ae81ff">4752919295672183050936727141176117974827669306505970380425030364810</span>, <span style="color:#ae81ff">14487800823220630104530546639228420223998682568934955015092250740112699729525</span>, <span style="color:#ae81ff">8295957536049799636308491371051629069883338278363081922835789737524</span>, <span style="color:#ae81ff">92731167790612205135291774049473551292159822402063205170980856740372630056525</span>, <span style="color:#ae81ff">48911170339932108013619485718407510367892447794792267935080828550259429009087094840546760649202737768887965367560824173815925167093584802995045480901320956581560002877396753186042687762670165406679210923009588244233506723056455864861467069619305079410363205804749852406712544677581254447296668231428972773607666397098772112388048760495377779243295009939980812022921662292510172072761693027121859641367893074500696251520030604911216339485263866502885184043858887300510599875422170899443259698459346020550049153415005928378278014411878775673693125888128402223380942730091302013331151085677287180296798600807422752017057</span>)
</span></span></code></pre></div><p>Again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> Crypto<span style="color:#f92672">.</span>Util<span style="color:#f92672">.</span>number <span style="color:#f92672">import</span> long_to_bytes
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> long_to_bytes(<span style="color:#ae81ff">706900059475064292686386702602426630444324681379114804503951298062869885</span>)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;flag{more_hashes!=more_secure}&#39;</span>
</span></span></code></pre></div><p>Let&rsquo;s write a SageMath function that recovers the flag using Babai algorithm.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cvp_approach</span>(H, A, p):
</span></span><span style="display:flex;"><span>    M <span style="color:#f92672">=</span> block_matrix([
</span></span><span style="display:flex;"><span>        [identity_matrix(<span style="color:#ae81ff">6</span>), matrix(H)<span style="color:#f92672">.</span>T],
</span></span><span style="display:flex;"><span>        [zero_matrix(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>), matrix([p])]
</span></span><span style="display:flex;"><span>    ], subdivide<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>    target <span style="color:#f92672">=</span> vector(ZZ, [<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">224</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">224</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">256</span>, A])
</span></span><span style="display:flex;"><span>    R <span style="color:#f92672">=</span> Babai_CVP(M, target)
</span></span><span style="display:flex;"><span>    flag <span style="color:#f92672">=</span> abs(int(R[<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> long_to_bytes(flag)
</span></span></code></pre></div><p>You can find a full working solve script <a href="https://github.com/rasti37/CTF-Writeups-and-Notes/blob/main/crypto/BackdoorCTF%202024/Hashing%20Frenzy/solve.py" target="_blank" rel="noopener">here</a>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I think this challenge really showcases the power of lattice reduction techniques and what happens when large portions of the secret information, are known. If you find any mistake in this writeup, feel free to reach out in Discord; my handle is <code>r4sti</code>.</p>
<p>See ya next time! ðŸ˜Ž</p>

		</div>
	</article>
</main>
<aside>
	<div>
		<div>
			<h3>RELATED POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li>2025-03-06 :: <a href="/posts/2025-03-06-tsj-ctf-2022-babyrsa/">(Crypto) TSJ CTF 2022 - babyRSA</a></li>
				
				<li>2025-03-02 :: <a href="/posts/2025-03-02-litctf-2023-lcg-squared/">(Crypto) LITCTF 2023 - LCG... Squared?</a></li>
				
				<li>2025-04-08 :: <a href="/posts/2025-04-08-a-deep-dive-into-donex-ransomware-part-1/">A Deep Dive into Donex Ransomware [Part 1]</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2025 :: <a href="http://localhost:1313/"
			class='header-footer-anchor'><b>rasti&#39;s knowledge cave</b></a> Â·
		
		<a href="https://github.com/rasti37" class='header-footer-anchor' target='_blank'><b>Github</b></a>
	</p>
</footer>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
  integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
  integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true }, 
        { left: '$', right: '$', display: false }, 
        { left: '\\(', right: '\\)', display: false }, 
        { left: '\\[', right: '\\]', display: true }, 
      ],
      throwOnError: false
    });
  });
</script>

</body>
</html>
